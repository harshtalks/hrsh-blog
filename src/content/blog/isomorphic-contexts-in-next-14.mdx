---
title: Isomorphic Contexts in Next.js 14
description: This blog is a deep dive on how to use isomorphic contexts in Next.js 14. We will learn how we can share data among parent and its child components in server components similar to the client components.
pubDate: 2024-06-08
published: true
featured: true
tags:
    - Typescript
    - Javascript
    - React
    - Functional Programming
    - Next.js
    - Node
---


<blockquote class="p-4 border-s-4 border-gray-300 bg-gray-50">
    <p class="text-xl italic font-medium leading-relaxed">isomorphic. adjective. iso·​mor·​phic ˌī-sə-ˈmȯr-fik. : being of identical or similar form or shape or structure.</p>
</blockquote>


If you've been part of the web ecosystem for a while, especially in Node.js (backend), you've likely encountered [isomorphic-fetch](https://www.npmjs.com/package/isomorphic-fetch). This library was crucial because fetch wasn't natively available in Node.js for a long time. 

"Isomorphic" in web development means code that runs unchanged on both client-side (browser) and server-side (e.g., Node.js). This approach lets developers write code once for use in multiple environments, streamlining development and maintaining consistency across the stack.

### What is an Isomorphic Context?

React core team, in their version 16.3 release, introduced a new feature called Context API. This API allows you to share data among parent and its child components without passing props down manually at every level. This is especially useful when you have deeply nested components and you need to pass data from the top to the bottom. There are situations where we need to share data between the server components with parent-child relationship. 

Next.js 13 introduced server components, which are components that run on the server and can be used to fetch data, perform server-side rendering, and more. Server components are a great way to improve performance and reduce the time it takes to load a page. But there are certain problems developers faced when using Next.js server components: 

1. No access of context in server components, as the context is not available in the server components.
2. You can't get pathname, search params or route params in the server components. and only possible way for now is to pass them as props to the server components from the page.

To solve these problems, People had workaround solutions such as marking leaf components as client components and use react/next hooks directly inside them such as `useRouter` or `useContext`. This works 90% of the time, but for the rest 10%, it's a pain to manage.


import { Image } from "astro:assets";

<Image
    src="https://miro.medium.com/v2/resize:fit:1154/1*bi1yIMb3lF1C8wJuhmxbmQ.jpeg"
    title={"party time builder io"}
    alt={"party time"}
    width={400}
    height={300}
    className="w-full h-full"
/>

### Server Contexts in Next.js 14

Luckily for us, solution also lies in the APIs provided to use by recent releases of Node.js and React 19 (We can access them in Next.js 14 as of now). The two of the solutions are:

1. AsyncLocalStorage in Node
2. Cache function from React 19


#### AsyncLocalStorage in Node

What is AsyncLocalStorage? It is a new feature in Node.js 16.8.0 that allows you to store data in a context that is accessible across async calls. This is especially useful when you need to share data between different parts of your application, such as middleware and route handlers. Next.js uses this internally for the `headers()` and `cookies()` functions. The fact that it only stays in the same async context (a single request response cycle) is what makes it perfect for server components as server components are never <strong>rerendered</strong> again once sent to the client. 

#### AsyncLocalStorage in action

We are in a Next.js environment with given file structure:

```bash
└── package.json
└── app
│   └── page.tsx
│   └── _components
│       └── ServerComponent.tsx
└── server-context
    └── context.tsx
```


Note: This blog requires you to have good knowledge of Typescript generics.

We have a `context.tsx` file inside the server-context folder and this is where we will define our logic for context that is shared among server component.

##### context.tsx
```tsx
// server-context/context.tsx
// We need to make sure that this file is only imported in server environment.
import "server-only";
import { AsyncLocalStorage } from "async_hooks";
// A helper type to wrap our generic type into an object. useful when you want to extend the context with additional metadata.
type BindServerContextStoreData<T> = {
    storeValue: T
}

// Type for our server context, we will try to make its signature similar to the react context so that it works well with our mental modal.
export type ServerContext<T> = {
  Provider: ({
    children,
    storeValue,
  }: {
    children: React.ReactNode;
    storeValue: T;
  }) => React.ReactNode;
  store: AsyncLocalStorage<BindServerContextStore<T>>;
  defaultValue: T;
};
```

Let's understand the above code:

1. We are importing `server-only` which is a file that is only available in the server environment. This is a good practice to make sure that the file is only imported in the server environment. If used in the client environment, it will throw an uncaught error.
2. We are importing `AsyncLocalStorage` from `async_hooks` which is a new feature in Node.js 16.8.0.
3. We are defining a type `BindServerContextStoreData` which is a helper type to wrap our generic type into an object. This is useful when you want to extend the context with additional metadata.
4. We are defining a type `ServerContext` which is a generic type that takes a type `T` and returns an object with three properties:
    - `Provider`: A React component that takes two props `children` and `storeValue` and returns a React node.
    - `store`: An instance of `AsyncLocalStorage` that takes a generic type `BindServerContextStore<T>`.
    - `defaultValue`: A default value of type `T`.

Now let's define our `ServerContext`:

```tsx
// server-context/context.tsx
export const createServerContext = <T,>(defaultValue: T): ServerContext<T> => {
  const store: ServerContext<T>["store"] = new AsyncLocalStorage<
    BindServerContextStore<T>
  >();
  return {
    Provider: ({ children, storeValue }) => {
      return (
        <Fragment>
          <SyncContext serverContextStore={store} storeValue={storeValue} />
          {children}
        </Fragment>
      );
    },
    store,
    defaultValue,
  };
};

// We need to inject the store into the context so that it is available in the server components as well.
const SyncContext = <T,>({
  serverContextStore,
  storeValue,
}: {
  serverContextStore: AsyncLocalStorage<BindServerContextStore<T>>;
  storeValue: T;
}) => {
  serverContextStore.enterWith({ storeValue });
  return null;
};
```

Let's understand the above code:
1. We are defining a function `createServerContext` that takes a generic type `T` and a default value of type `T` and returns an object of type `ServerContext<T>`.
2. Inside the function, we are creating an instance of `AsyncLocalStorage` with the generic type `BindServerContextStore<T>`.
3. We are returning an object with three properties:
    - `Provider`: A React component that takes two props `children` and `storeValue` and returns a React node.
    - `store`: An instance of `AsyncLocalStorage` that takes a generic type `BindServerContextStore<T>`.
    - `defaultValue`: A default value of type `T`.
4. We are defining a component `SyncContext` that takes two props `serverContextStore` and `storeValue` and returns `null`.
    - This piece of code is very important as `enterWith` sets up a new asynchronous context with a predefined store value. Unlike run, it doesn't require a callback and affects all subsequent async operations in the current execution context. It's useful for scenarios where you need to establish a persistent context across multiple async operations without nesting callbacks. This method is particularly valuable in middleware scenarios or when setting up context for a series of related async tasks. 

Now let's create a function to consume the context:

```tsx
// server-context/context.tsx
export const useServerContext = <T,>(serverCtx: ServerContext<T>) => {
  const store = serverCtx.store.getStore();
  return store?.storeValue || serverCtx.defaultValue;
};
```

Let's understand the above code:
1. We are defining a function `useServerContext` that takes a generic type `T` and a `ServerContext<T>` and returns the store value or the default value of the context.
2. Inside the function, we are getting the store value from the context using `getStore` method and returning the store value or the default value of the context.

In just three lines of code, we got similar functionality to the React context API `useContext`. Now let's see how we can use this context in our server components.

Example: We need to use search params in our server component. We all know that in the current implementation of Next.js, we can't get search params in the server components. We need to pass them as props to the server components from the page or use client components to access search params using `useSearchParams`

```tsx
// app/page.tsx
import { ServerComponent } from "./_components/ServerComponent";
import { createServerContext } from "@/server-context/context";

type SearchParamsType = {
  [k: string]: undefined | string | string[];
};

export const ctx = createServerContext<SearchParamsType>({});

export default function Home({
  searchParams,
}: {
  searchParams: SearchParamsType;
}) {
  return (
    <ctx.Provider storeValue={searchParams}>
      <main className="flex min-h-screen flex-col items-center justify-between p-24">
        <ServerComponent />
      </main>
    </ctx.Provider>
  );
}
```

What we are doing here is:
1. We are importing `ServerComponent` from `_components/ServerComponent`.
2. We are importing `createServerContext` from `server-context/context`.
3. We are defining a type `SearchParamsType` which is an object with keys of type `string` and values of type `undefined | string | string[]`.
4. We are creating a context `ctx` using `createServerContext` with a default value of an empty object.
5. We are defining a function `Home` that takes an object with a key `searchParams` of type `SearchParamsType`.
6. Note that this implementation needs a defaultValue, you can choose to keep it optional.

Now let's see how we can use the context in our server component:

```tsx
// app/_components/ServerComponent.tsx
import { useServerContext } from "@/server-context/context";
import { ctx } from "../page";

export const ServerComponent = () => {
  const value = useServerContext(ctx);
  return <div>this is a server context - {JSON.stringify(value)}</div>;
};
```

What we are doing here is:
1. We are importing `useServerContext` from `server-context/context`.
2. We are importing `ctx` from `../page`.
3. We are defining a component `ServerComponent` that uses the `useServerContext` hook with the `ctx` context.


With just a single file, and a few lines of code, we have created a server context that can be used in server components. This is a powerful feature that can be used to share data between server components and pass data from the top to the bottom of the component tree without having to pass props manually at every level.


### Making it Isomorphic

To make our context isomorphic, we need to make sure that it works on the client as well. we can achieve it by creating another context but this time using the React context API. Let's see how we can do it. There is a myth that we can't use React context in server components, but that's not true. We can use React context in server components as well and no, the children of a react context can be server component as well. However, the context itself can't be a server component and consumers of the context can't be server components. 

Ideally what we will end up with is: 

```tsx
// app/page.tsx
import { ServerComponent } from "./_components/ServerComponent";
import { createServerContext } from "@/server-context/context";

type SearchParamsType = {
  [k: string]: undefined | string | string[];
};

export const ctx = createServerContext<SearchParamsType>({});

export default function Home({
  searchParams,
}: {
  searchParams: SearchParamsType;
}) {
  return (
    <ctx.Provider storeValue={searchParams}>
    <ClientCtx.Provider value = {searchParams}>
      <main className="flex min-h-screen flex-col items-center justify-between p-24">
        <ServerComponent />
      </main>
    </ctx.Provider>
    </ClientCtx.Provider>
  );
}
```



#### cache() in React 19 (or Next 14)

If you remember, the only reason we were able to use `AsyncLocalStorage` in the server environment was because it preserves the value inside its store for a single request-response cycle and React Server Components are never rerendered once sent to the client. So React's `cache()` function also qualifies for this use case.

##### What is cache() in React 19?

React 19 introduced a new feature called `cache()`. This function allows you to cache the result of a function call and reuse it across components in a single request cycle (single render, thus making it perfect for sharing data across server components). 

- It only works with React Server Components.
- React will invalidate the cache for all memoized functions for each server request.


##### cache() in action

Let's see how we can use `cache()` in our server components:

```tsx
import { cache } from "react";

export const cacheStore = cache(() => {
  return new Map<string, string>();
});

export const setCacheStore = (key:string,value:string) => {
    cacheStore().set(key,value)
}

export const getCacheStore = (key:string) => {
    return cacheStore().get(key)
}
```

What we are doing here is:
1. We are importing `cache` from `react`.
   - This will cache the map for one render (one request cycle) and all the components that uses/consumes this cached map object will receive the same object. 
   - Since the server response for a page comes in a sequence, therefore, when we set the value in a parent component, the child component will receive the updated value. and changing the same later on in the child component will affect the parent component as well. (This is the same behavior as `AsyncLocalStorage` or React Context)
2. We are defining a function `cacheStore` that returns a new `Map<string, string>`.
3. We are defining a function `setCacheStore` that takes a `key` and a `value` and sets the `key` and `value` in the cache store.
4. We are defining a function `getCacheStore` that takes a `key` and returns the value of the `key` from the cache store.

Now let's see how we can use the cache in our server components:

```tsx
// page.tsx
import Image from "next/image";
import { ServerComponent } from "./_components/ServerComponent";
import { createServerContext } from "@/server-context/context";
import { cacheStore, setCacheStore } from "@/server-context/cached-store";

type SearchParamsType = {
  [k: string]: undefined | string | string[];
};

export const ctx = createServerContext<SearchParamsType>({});

export default function Home({
  searchParams,
}: {
  searchParams: SearchParamsType;
}) {
  setCacheStore("hello", "world");
  return (
    <ctx.Provider storeValue={searchParams}>
      <main className="flex min-h-screen flex-col items-center justify-between p-24">
        <ServerComponent />
      </main>
    </ctx.Provider>
  );
}
```

here we have set the value in the parent component and we will see how we can access the same value in the child component.

```tsx
// _components/ServerComponent.tsx
import { useServerContext } from "@/server-context/context";
import { ctx } from "../page";
import { getCacheStore } from "@/server-context/cached-store";

export const ServerComponent = () => {
  const value = useServerContext(ctx);
  return (
    <div>
      this is a server context - {JSON.stringify(value)} -{" "}
      {getCacheStore("hello")}
    </div>
  );
};
```

We are using the `getCacheStore` function to get the value of the key `hello` that we set in the parent component. 

This is how we can use the `cache()` function in React 19 to share data across server components.


### When to use it:

in 95% of the cases, you do not need any of these solutions. I have this theory that if you need to rely some custom implementation or a hacky solution so much in a vert opinionated framework like Next.js, you are probably doing something wrong. However there are times when you do not have any other option but to use these solutions.

1. When you need to share data between server components.
2. When you want search params, path params or pathname in the server components.
3. When you want to use any Next specific config in the server components.

NOTE: Please make sure, you are not using these solutions in Layout.tsx as Layout.tsx are not rerendered on every request cycle and you may get stale/unwanted data.
Please read for more: - https://github.com/vercel/next.js/issues/43704#issuecomment-2090798307 

Working Codesandbox: https://codesandbox.io/p/devbox/isomorphic-context-n45z8j

## References:

- https://www.freecodecamp.org/news/async-local-storage-nodejs/
- https://react.dev/reference/react/cache
- https://nextjs.org/docs/app/building-your-application/caching#request-memoization
